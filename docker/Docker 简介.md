---
title: Docker 简介
tags: [Notebooks]
created: '2019-05-11T08:56:08.897Z'
modified: '2019-05-11T09:30:29.356Z'
---

- Docker 简介
  - Docker 是一种虚拟化的解决方法.
  - 与传统的虚拟化区别 传统的虚拟化是物理机通过虚拟监视器(Virtual Machine Monitor,VMM 也称Hypervidor)的模拟,使虚拟机中的操作系统(Guest OS 操作系统)认为自己仍然是一个系统在运行,而容器是属于直接运行在操作系统之上的用户空间(**因此 容器虚拟化也称为操作系统虚拟化**).
  - 由于依赖操作系统的特性,容器只能运行相同或者 相似内核的操作系统之上.
  - docker 的运行依赖于linux内核 特性 Namesapce 和 Cgroup(Control Group) **docker 只能运行linux系统 不能运行 windows 系统** 
  ![linux容器技术 VS 虚拟机](https://raw.githubusercontent.com/stone1993/pic_bed/master/docker/linux%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E6%AF%94.jpg  "linux容器技术 VS 虚拟机")
  ##### 容器技术与传统虚拟机技术对比 
   - 由图中可以看到,容器技术相对于虚拟机技术,**占用的磁盘资源更少**,使用虚拟机部署应用,不仅仅需要应用、库、还需要完整的操作系统.容器技术只需要应用和对应的库,因此,资源占用大大减少.
   - 虚拟机需要模拟硬件的行为 对内存和 CPU的损耗 也相当大.因此 同样配置的服务器 容器技术比使用虚拟机技术提高更多的运算能力,服务更多的用户.
   #### Docker 技术简介
   - 将应用程序自动部署到容器的开源引擎.
   - Docker 使用GO语言编写
   - 2013年初 由dotCloud公司发布
   - 基于apache 2.0 开源授权协议
   - Docker在容器化的虚拟化执行程序中,增加了一个应用程序部署引擎,引擎目标,提高快速、轻量的环境 ,能够运行开发者程序,并方便高效的将程序从开发者环境,部署到测试环境,再到生产环境
   #### Docker的目标
   - **提供简单轻量的建模方式** 用户只需要几分钟就可以将程序DOcker化,Docker容器的启动运行大多数只需要一秒,由于去除了管理程序的开销,Docker性能高,同一宿主机中可以运行更多的容器,使用户可以尽可能的利用系统资源
   - **指责的逻辑分明** 使用Docker 开发人员只需要注意容器中的应用程序,运维人员只需要管理容器,Docker的目的,就是加强开发人员写代码的环境 与 实际生产环境的一致性
   - **快速高效的生命周期** Docker的目标之一就是缩短代码从开发、测试、部署上线运行的周期,使应用程序具备可移植性,在容器中开发,以容器的形式交互分发.如此 开发-测试-生产 都使用相同的环境 也就避免了额外的调试、部署相应的开销.这样 就能够有效缩短产品的上线周期
   - **鼓励使用面向服务的架构** Docker推荐单个程序 只运行一个应用程序或者进程,如此就形成分布式程序设计模型,在这样程序下,应用程序和服务都可以表示成一系列内部互连的容器,从而使分布式部署应用程序扩展或者调试应用程序变的特别简单.开发中常用的思想**高内聚 低耦合 单一任务** 这样就能够避免在同一服务器部署不同服务时,可能带来的服务之间互相影响,在运行过程中,出现问题,也比较容易定位问题的所在.
   #### Docker的使用场景
   - **使用Docker开发、测试、部署服务**. 因为Docker本身非常轻量化.本地开发人员可以构建、分享容器.容器可以在开发环境构建,再提交给测试,最终进入生产环境
   - **创建隔离的运行环境** 在企业应用中,同一服务的不同版本可能服务不同的用户,那么使用Docker非常容易创建不同的生产环境,来运行不同的服务.
   - **搭建测试环境** 由于Docker轻量化 开发者很容易利用Docker在本地搭建测试环境,用来测试程序在不同系统下的兼容性,甚至搭建集群测试环境,而学生也很容易利用Docker搭建开发环境.
   - **构建多用户的 平台即服务(PaaS)基础设施**
   - **提供软件即服务(SaaS)应用程序.**
   - **高性能 超大规模的宿主机部署** 目前AWS、阿里云能公有云服务都提供了对Docker的支持,使开发者利用云平台,利用Docker搭建PAAS、SaaS的服务,同时,有很多开发者在使用openstack和Docker结合,提供PaaS和SaaS的服务,使Docker在云计算领域,有着明朗的前景.
### Docker 基本组成
- Docker Client客户端
- Docker Daemon守护进程
- Docker Image 镜像
- Docker Container容器
- Docker Resister 仓库 
#### 客户端/守护进程
- **C/S架构** Docker的客户端向Docker的服务端(DOcker的守护进程)发出请求,守护进程处理完所有的工作,并返回结果.
- **本地/远程** docker的客户端 对服务端的 访问既在本地 也可以通过远程来访问 
Docker客户端 与 服务端 交互图
![Docker 客户端/守护进程](https://raw.githubusercontent.com/stone1993/pic_bed/master/docker/docker客户端:守护进程.jpg  "Docker 客户端/守护进程")
#### Docker镜像
- **镜像是Docker的基石** 容器基于镜像的启动、运行.镜像就好比为容器的源代码,保存了用于启动容器的各种条件.
- **层叠的只读文件系统**
  -  最底层为引导文件系统(bootfs),很像linux引导文件系统.Docker用户基本永远不需要与引导文件系统交互.实际上,当容器启动后,它将移动到内存中,引导文件系统将会被卸载.
  -  rootfs(Ubuntu)文件系统,rootfs可以是一种或多种文件系统,比如(Ubuntu 或者CentOS),在传统linux系统中,rootfs会先以只读的形式加载,当引导结束并完成完整性检查后,它才会被切换为读写模式,**但是在Docker里 ,rootfs永远只能是只读状态**
  -  并且Docker利用联合加载技术(union mount),在rootfs文件系统之上,加载更多的只读文件系统,**联合加载指的是一次加载多个文件系统,但是在外界看来,只能看到一个文件系统 联合加载会将各层文件系统叠加到一起 最终的文件系统包含所有的文件和底层目录 Docker将这样的文件系统称为镜像** 一个镜像可以放到另一个镜像的顶部,位于下面的镜像称为父镜像,可以以此类推,最底部的镜像称为基础镜像,也就是图中rootfs文件系统.
  ![docker镜像结构](https://raw.githubusercontent.com/stone1993/pic_bed/master/docker/docker镜像结构.jpg "Docker镜像结构")
 #### Docker Container容器
 - **容器通过镜像启动** Docker的容器是Docker的执行单元,容器中可以运行客户的一个/多个进程.
 - **启动和执行阶段** 如果说镜像是Docker生命周期的构建打包阶段,那么容器则是启动和执行阶段,当一个容器启动时,Docker会在容器的最顶层加载一个**读写文件系统**,我们在Docker中运行程序,就是在这个层中执行的.
 - 当Docker第一次启动时,初始的读写层是空的,当文件系统发生变化时,这些变化都会出现在这一层上,比如,如果想修改一个文件,这个文件会从读写层下的只读层复制到读写层.该文件的只读版本依然存在,但是,已经被读写层的文件副本所隐藏.这就是Docker中的一项重要技术,**写时复制 copy in write** 每个只读镜像层都是只读的,并且永远都不会变化,当创建一个新容器时,docker会构建一个镜像栈,就像如图所示,在栈的最顶层添加**可写层**,容器的读写层加上镜像层 加上配置数据 构成了我们完整的容器.容器的这个特点,加上镜像的分层框架,使我们可以快速的构建,并运行包含我们自己的应用程序和服务的容器.
  ![docker容器结构](https://raw.githubusercontent.com/stone1993/pic_bed/master/docker/docker容器结构.jpg "Docker容器结构")
 
 #### Docker Registry 仓库
 - Docker利用仓库来保存构建容器的镜像
 - 仓库分为 公有/私有 两种
 - Docker公司提供的公有服务Docker Hub,我们可以自己创建账户 分享和保存自己的镜像,Docker Hub上已经有了非常丰富的镜像,所以我们可以利用Docker HUB查找我们需要的镜像 节省我们的时间.
 - 当然我们可以架设我们私有的仓库
 ##### 总结Docker的组成部分
  客户端来访问Docker的守护进程,从而操作Docker的容器,而容器是通过镜像来创建,而镜像又保存在仓库
 ![docker基本组成](https://raw.githubusercontent.com/stone1993/pic_bed/master/docker/docker基本组成.jpg "Docke基本组成")
 

 docker版本 docker version
 docker仓库查找镜像 docker search image_name
 docker从仓库拉取镜像
 docker pull username/image_name 
 拉取需要全名 
  
  

### Docker 容器相关简介
#### Docker依赖的Linux内核特性
 - Namespaces 命名空间 
 - Control Groups(cgroups)控制组
#### Namespaces 命名空间
 - 很多编程语言都有命名空间的概念,命名空间是一种封装的概念.封装本身实现的是代码的隔离.
 - 在操作系统中,命名空间实现的是系统资源的隔离,资源包括:进程、网络、文件系统.
 - linux使用命名空间的目的就是轻量级虚拟化服务,即容器.
 - 在同一命名空间下的进程可以感知彼此的变化,而对其他进程的命名空间一无所知,让让容器中的进程产生一个错觉,仿佛自己处于一个独立的系统环境中,以此达到独立和隔离的目的.
 - Docker使用了5种命名空间.
   - PID(Process ID)进程隔离
   - NET (Network) 管理网络接口
   - IPC (InterProcess Communication)管理跨进程通信的访问
   - MNT (Mount) 管理挂载点
   - UTS (Unix Timesharing System)隔离内核和版本标识
  - 隔离的资源 如何管理 Control groups 控制组
    - control group是linux 提供的一种可以限制、记录、隔离进程组所使用物理资源的机制.
    - 最初由Google 工程师提出
    - 最初实现于 linux kernel 2.6.24@2007 
    - Control groups 就是为容器而生.
    - Control 功能
      - **资源限制** 例如:VMM子系统可以为进程组设定内存使用上限,一旦进程组所使用资源超过限额,使用资源就会发出 OutMemmary 消息
      - **优先级设定** 可以设定那些进程组使用更大的CPU,或者是磁盘IO的资源.
      - **资源计量** 计算进程组使用了多少系统资源,尤其在计费系统中.
      - **资源控制** 可以将进程组挂起和恢复
#### Docker容器的能力
- **文件系统隔离**:每个容器都有自己的root文件系统.
- **进程隔离**:每个容器都处于自己的进程环境中
- **网络隔离**:容器间的虚拟网络接口和IP地址都是分开的.
- **资源隔离分组**:使用Cgroup将CPU和内存之内的资源独立的分配给每个Docker容器.   

